<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mars 404 Not Found</title>
  <link rel="stylesheet" href="./assets/css/space.css">
</head>
<body>
  <canvas id="space"></canvas>

  <script>
 const canvas = document.getElementById("space");
const ctx = canvas.getContext("2d");

let width = window.innerWidth;
let height = window.innerHeight;
canvas.width = width;
canvas.height = height;

const numStars = 600;
const stars = [];

function randomRange(min, max) {
  return Math.random() * (max - min) + min;
}

// Crear estrellas con distintos tonos
for (let i = 0; i < numStars; i++) {
  // Colores con ligeras variaciones
  const hues = [0, 40, 60, 200, 220, 280]; // rojo, dorado, blanco cÃ¡lido, azul claro, celeste, violeta
  const hue = hues[Math.floor(Math.random() * hues.length)];

  stars.push({
    x: randomRange(-width, width),
    y: randomRange(-height, height),
    z: randomRange(0.1, width),
    hue,
    baseOpacity: Math.random() * 0.5 + 0.15,
    twinkleSpeed: randomRange(0.001, 0.008),
    twinklePhase: Math.random() * Math.PI * 2,
  });
}

function draw() {
  ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
  ctx.fillRect(0, 0, width, height);

  for (let i = 0; i < numStars; i++) {
    const s = stars[i];
    s.z -= 1.2; // ðŸ”¹ velocidad mÃ¡s lenta y suave

    // Si pasa del lÃ­mite, vuelve atrÃ¡s simulando flujo constante
    if (s.z <= 1) {
      s.x = randomRange(-width, width);
      s.y = randomRange(-height, height);
      s.z = width;
    }

    const scale = 300 / s.z;
    const x = width / 2 + s.x * scale;
    const y = height / 2 + s.y * scale;
    if (x < 0 || x >= width || y < 0 || y >= height) continue;

    // ðŸ”¹ tamaÃ±o un poco menor
    const depthFactor = 1 - s.z / width;
    const size = Math.max(0.2, depthFactor * 2.2);

    // ðŸ”¹ titileo
    s.twinklePhase += s.twinkleSpeed;
    const twinkle = 0.6 + Math.sin(s.twinklePhase) * 0.4;

    // ðŸ”¹ opacidad segÃºn distancia (mÃ¡s cerca â†’ mÃ¡s visible)
    const opacity = Math.min(1, s.baseOpacity + depthFactor * 1.4 * twinkle);

    // ðŸ”¹ color con matiz segÃºn hue
    ctx.fillStyle = `hsla(${s.hue}, 100%, 85%, ${opacity})`;

    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.fill();
  }

  requestAnimationFrame(draw);
}

window.onload = draw;

window.addEventListener("resize", () => {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
});


  </script>
</body>
</html>
